package com.admin.codegenreallynew.util;

import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import javax.annotation.processing.Generated;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.text.StrMatcher;
import org.apache.commons.lang3.text.StrTokenizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.domain.Specification;

@Generated(value = "com.exocoding.codegen", comments = "Generated by ExoCoding")
public class FilterBuilder {

  private static final Logger logger = LoggerFactory.getLogger(FilterBuilder.class);
  private static final String LEFT_PARENTHESIS = "(";
  private static final String RIGHT_PARENTHESIS = ")";

  public static <E> Specification<E> from(String filterExpression) {
    return toSpec(toPostfix(filterExpression));
  }

  /**
   * Processes an input expression (in 'infix' notation) to an equivalent expression (in 'postfix'
   * notation).
   *
   * <p><a
   * href="https://www.geeksforgeeks.org/convert-infix-expression-to-postfix-expression/">Infix
   * Notation</a>
   *
   * @param infixExpression filter expression (in 'infix' notation).
   * @return processed expression tokens (in 'postfix' notation).
   */
  @SuppressWarnings("deprecation")
  private static String[] toPostfix(String infixExpression) {
    Deque<String> stack = new LinkedList<>();
    Deque<String> output = new LinkedList<>();

    // space out any joined parenthesis
    String input =
        StringUtils.replaceEachRepeatedly(
            infixExpression, new String[] {"(", ")"}, new String[] {" ( ", " ) "});

    // split into tokens
    StrTokenizer strTokenizer =
        new StrTokenizer(input)
            .setDelimiterMatcher(StrMatcher.spaceMatcher()) // break on spaces
            .setQuoteMatcher(StrMatcher.singleQuoteMatcher()) // accept single quotes
            .setTrimmerMatcher(StrMatcher.trimMatcher()); // perform trims

    while (strTokenizer.hasNext()) {
      // process each token
      String token = strTokenizer.next();
      FilterOperator tokenOp = FilterOperator.fromString(token);
      if (tokenOp != null) {
        // Operator (Unary/Binary)
        while (!stack.isEmpty()
            && tokenOp.isHigherPrecedence(FilterOperator.fromString(stack.peek()))) {
          // Pop all the operators from the stack which are
          // greater than or equal to the scanned operator
          output.push(stack.pop());
        }
        // then push it in the stack
        stack.push(tokenOp.getKeyword());
      } else if (token.equals(LEFT_PARENTHESIS)) {
        // Left parenthesis -> push it to the stack
        stack.push(token);
      } else if (token.equals(RIGHT_PARENTHESIS)) {
        // Right parenthesis -> pop the stack and output it until a '(' is encountered
        while (!stack.isEmpty() && !stack.peek().equals(LEFT_PARENTHESIS)) {
          output.push(stack.pop());
        }
        // discard both parenthesis
        stack.pop();
      } else {
        // Operand -> Add to the output
        output.push(token);
      }
    }

    // Pop the stack and add the operators in the output expression
    // until it is not empty
    while (!stack.isEmpty()) {
      output.push(stack.pop());
    }
    Collections.reverse((List<?>) output);

    if (logger.isDebugEnabled()) {
      logger.debug("toPostfix input: {}", infixExpression);
      logger.debug("toPostfix output: {}", ArrayUtils.toString(output.toArray()));
    }
    return output.toArray(String[]::new);
  }

  /**
   * Constructs a Specification with all the provided filters. <a
   * href="https://www.geeksforgeeks.org/evaluation-of-postfix-expression/">Evaluate postfix</a>
   *
   * @param postfixExpressionTokens input expression tokens (in 'postfix' notation).
   * @return a specification including all provided filters.
   */
  private static <E> Specification<E> toSpec(String[] postfixExpressionTokens) {
    Deque<Object> specStack = new LinkedList<>();
    for (String token : postfixExpressionTokens) {
      FilterOperator operator = FilterOperator.fromString(token);
      if (operator != null) {
        if (operator.isUnary() && specStack.size() >= 1) {
          Object left = specStack.pop();
          if (left instanceof Specification<?>) {
            Specification<E> l = (Specification<E>) left;
            if (operator == FilterOperator.NOT) {
              specStack.push(Specification.not(l));
            }
          }
        } else if (specStack.size() >= 2) {
          Object left = specStack.pop();
          Object right = specStack.pop();
          if (left instanceof String l && right instanceof String r) {
            // Comparison operator
            FilterCriteria filterCriteria = new FilterCriteria(r, operator, l);
            specStack.push(new FilterSpecification<E>(filterCriteria));
          } else if (left instanceof Specification<?> && right instanceof Specification<?>) {
            // Logical operator
            Specification<E> l = (Specification<E>) left;
            Specification<E> r = (Specification<E>) right;
            if (operator == FilterOperator.OR) {
              specStack.push(Specification.where(l).or(r));
            } else if (operator == FilterOperator.AND) {
              specStack.push(Specification.where(l).and(r));
            }
          }
        }
      } else {
        specStack.push(token);
      }
    }
    return specStack.size() > 0 ? (Specification<E>) specStack.getFirst() : null;
  }
}
